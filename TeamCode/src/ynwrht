package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.ColorSensor;
import android.graphics.Color;
import android.view.View;
import android.app.Activity;

@Autonomous(name = "ColorCrater", group = "Linear Opmode")

public class ColorCrater extends LinearOpMode {

    @Override
    public void runOpMode() {

        telemetry.addData("Status", "Initialized");
        telemetry.update();

        motor3 = hardwareMap.get(DcMotor.class, "motor3");

        motor3.setDirection(DcMotor.Direction.REVERSE);

        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        waitForStart();
        runtime.reset();

// Lower
        motor3.setTargetPosition(13900);

        telemetry.addData("Status","Run Time: " + runtime.toString());

        motor3.setPower(1);

        while(motor3.isBusy() && opModeIsActive()){
            telemetry.update();
        }
        motor3.setPower(0);

        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
/*
        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

// Go forward to remove hook
        motor1.setTargetPosition(310);
        motor2.setTargetPosition(310);
        motor3.setTargetPosition(310);
        motor4.setTargetPosition(310);

        telemetry.addData("Status","Run Time: " + runtime.toString());
        telemetry.update();

        motor1.setPower(0.85);
        motor2.setPower(0.85);
        motor3.setPower(0.85);
        motor4.setPower(0.85);

        while(motor1.isBusy()&& motor2.isBusy()&& motor3.isBusy()&& motor4.isBusy() && opModeIsActive()){
            telemetry.update();
        }
        motor1.setPower(0);
        motor2.setPower(0);
        motor3.setPower(0);
        motor4.setPower(0);

        motor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

// Turn right
        motor1.setTargetPosition(777);
        motor2.setTargetPosition(777);
        motor3.setTargetPosition(-777);
        motor4.setTargetPosition(-777);

        telemetry.addData("Status","Run Time: " + runtime.toString());
        telemetry.update();

        motor1.setPower(0.5);
        motor2.setPower(0.5);
        motor3.setPower(0.5);
        motor4.setPower(0.5);

        while(motor1.isBusy()&& motor2.isBusy()&& motor3.isBusy()&& motor4.isBusy()&& opModeIsActive()){
            telemetry.update();
        }
        motor1.setPower(0);
        motor2.setPower(0);
        motor3.setPower(0);
        motor4.setPower(0);

        motor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

// Go forward towards wall
        motor1.setTargetPosition(3550);
        motor2.setTargetPosition(3550);
        motor3.setTargetPosition(3550);
        motor4.setTargetPosition(3550);

        telemetry.addData("Status","Run Time: " + runtime.toString());
        telemetry.update();

        motor1.setPower(0.85);
        motor2.setPower(0.85);
        motor3.setPower(0.85);
        motor4.setPower(0.85);

        while(motor1.isBusy()&& motor2.isBusy()&& motor3.isBusy()&& motor4.isBusy()&& opModeIsActive()){
            telemetry.update();
        }
        motor1.setPower(0);
        motor2.setPower(0);
        motor3.setPower(0);
        motor4.setPower(0);

        motor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

// Turn right

        Turn(90);

// Back up towards depot

        Straight(-60);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

// Drop marker

        servo1.setPosition(0.1);

        sleep(1400);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        int Gold = 0;
        int Pos = 0;

// Raise sorter
        servo1.setPosition(1);
// Drive towards crater
        Straight(49);
// Turn right
        Turn(90);
// Square up against wall
        Straight(-7);
// Drive forward from wall
        Straight(8);
// Turn left towards minerals
        Turn(-42);
// Drive forward towards 1st mineral
        Straight(15.5);
// Lower color sensor arm
        servo2.setPosition(0.73);
        colorTwo();
// Check minerals

        if(color() == true){
            Pos = 1;
            Gold = 1;
        }
        if(Gold == 0){
            Straight(14);
            if(color() == true){
                Pos = 2;
                Gold = 1;
            }
        }
        if(Gold == 0){
            Pos = 3;
            Straight(14);
        }
// Turn towards gold mineral
        Turn(-60);
// Knock off the gold mineral and drive into the crater
        Straight(12);
    }
    private boolean color() {
        // hsvValues is an array that will hold the hue, saturation, and value information.
        float hsvValues[] = {0F,0F,0F};

        // values is a reference to the hsvValues array.
        final float values[] = hsvValues;

        // get a reference to the RelativeLayout so we can change the background
        // color of the Robot Controller app to match the hue detected by the RGB sensor.
        int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier("RelativeLayout", "id", hardwareMap.appContext.getPackageName());
        final View relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);

        // bPrevState and bCurrState represent the previous and current state of the button.
        boolean bPrevState = false;
        boolean bCurrState = false;

        // bLedOn represents the state of the LED.
        boolean bLedOn = true;

        // get a reference to our ColorSensor object.
        colorSensor = hardwareMap.get(ColorSensor.class, "colorR");

        // Set the LED in the beginning
        colorSensor.enableLed(bLedOn);

        // wait for the start button to be pressed.

        runtime.reset();

        // while the op mode is active, loop and read the RGB data.
        // Note we use opModeIsActive() as our loop condition because it is an interruptible method.
        while (opModeIsActive() && runtime.milliseconds() <= 2000) {

            // check the status of the x button on either gamepad.
            bCurrState = gamepad1.x;

            // check for button state transitions.
            if (bCurrState && (bCurrState != bPrevState))  {

                // button is transitioning to a pressed state. So Toggle LED
                bLedOn = !bLedOn;
                colorSensor.enableLed(bLedOn);
            }

            // update previous state variable.
            bPrevState = bCurrState;

            // convert the RGB values to HSV values.
            Color.RGBToHSV(colorSensor.red() * 8, colorSensor.green() * 8, colorSensor.blue() * 8, hsvValues);

            // send the info back to driver station using telemetry function.
            telemetry.addData("LED", bLedOn ? "On" : "Off");
            telemetry.addData("Clear", colorSensor.alpha());
            telemetry.addData("Red  ", colorSensor.red());
            telemetry.addData("Green", colorSensor.green());
            telemetry.addData("Blue ", colorSensor.blue());
            telemetry.addData("Hue", hsvValues[0]);

            if(hsvValues[0] > 100){
                telemetry.addData("Mineral", "Silver");
                telemetry.update();
                // return false;
            }else if(hsvValues[0] < 100){
                telemetry.addData("Mineral", "Gold");
                telemetry.update();
                return true;
            }else{
                telemetry.addData("Mineral", "unknown");
                telemetry.update();
            }
        }
        return false;
    }
    private boolean colorTwo() {
        // hsvValues is an array that will hold the hue, saturation, and value information.
        float hsvValues[] = {0F,0F,0F};

        // values is a reference to the hsvValues array.
        final float values[] = hsvValues;

        // get a reference to the RelativeLayout so we can change the background
        // color of the Robot Controller app to match the hue detected by the RGB sensor.
        int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier("RelativeLayout", "id", hardwareMap.appContext.getPackageName());
        final View relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);

        // bPrevState and bCurrState represent the previous and current state of the button.
        boolean bPrevState = false;
        boolean bCurrState = false;

        // bLedOn represents the state of the LED.
        boolean bLedOn = true;

        // get a reference to our ColorSensor object.
        colorSensor = hardwareMap.get(ColorSensor.class, "colorR");

        // Set the LED in the beginning
        colorSensor.enableLed(bLedOn);

        // wait for the start button to be pressed.

        runtime.reset();

        // while the op mode is active, loop and read the RGB data.
        // Note we use opModeIsActive() as our loop condition because it is an interruptible method.
        while (opModeIsActive() && runtime.milliseconds() <= 2000) {

            // check the status of the x button on either gamepad.
            bCurrState = gamepad1.x;

            // check for button state transitions.
            if (bCurrState && (bCurrState != bPrevState))  {

                // button is transitioning to a pressed state. So Toggle LED
                bLedOn = !bLedOn;
                colorSensor.enableLed(bLedOn);

                // update previous state variable.
                bPrevState = bCurrState;

                // convert the RGB values to HSV values.
                Color.RGBToHSV(colorSensor.red() * 8, colorSensor.green() * 8, colorSensor.blue() * 8, hsvValues);

                // send the info back to driver station using telemetry function.
                telemetry.addData("LED", bLedOn ? "On" : "Off");
                telemetry.addData("Clear", colorSensor.alpha());
                telemetry.addData("Red  ", colorSensor.red());
                telemetry.addData("Green", colorSensor.green());
                telemetry.addData("Blue ", colorSensor.blue());
                telemetry.addData("Hue", hsvValues[0]);
                Straight(0.5);
                if(hsvValues[0] != 0.0){
                    return true;
                }else{
                    telemetry.addData("Mineral", "unknown");
                    telemetry.update();
                }
            }
        }
        return false;
    }
    private void motorConfig() {
        motor1 = hardwareMap.get(DcMotor.class, "motor1");
        motor2 = hardwareMap.get(DcMotor.class, "motor2");
        motor3 = hardwareMap.get(DcMotor.class, "motor3");
        motor4 = hardwareMap.get(DcMotor.class, "motor4");
        motor5 = hardwareMap.get(DcMotor.class, "motor5");
        servo1 = hardwareMap.get(Servo.class, "servo1");
        servo2 = hardwareMap.get(Servo.class, "servo2");
        motor1.setDirection(DcMotor.Direction.REVERSE);
        motor2.setDirection(DcMotor.Direction.REVERSE);
        motor5.setDirection(DcMotor.Direction.REVERSE);

    }
    private void Straight(double inches){

        double ticks = (inches / Circumfrence);
        int dist = (int)(ticks * TPR * gearRatio);

        motor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        motor1.setTargetPosition(dist);
        motor2.setTargetPosition(dist);
        motor3.setTargetPosition(dist);
        motor4.setTargetPosition(dist);

        motor1.setPower(0.85);
        motor2.setPower(0.85);
        motor3.setPower(0.85);
        motor4.setPower(0.85);

        while(motor1.isBusy() && motor2.isBusy() && motor3.isBusy() && motor4.isBusy() && opModeIsActive()){
            telemetry.update();
        }
        motor1.setPower(0);
        motor2.setPower(0);
        motor3.setPower(0);
        motor4.setPower(0);
    }

    private void Turn(int angle){
        double ticks = (angle / Circumfrence);
        int dist = (int)(ticks * TPR * gearRatio);
        double turn = 5.1;
        int distance = (int)(dist / turn);

        motor1.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor2.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor3.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        motor4.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        motor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor3.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        motor4.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        motor1.setTargetPosition(distance);
        motor2.setTargetPosition(distance);
        motor3.setTargetPosition(-distance);
        motor4.setTargetPosition(-distance);

        motor1.setPower(1);
        motor2.setPower(1);
        motor3.setPower(-1);
        motor4.setPower(-1);

        while(motor1.isBusy() && motor2.isBusy() && motor3.isBusy() && motor4.isBusy() && opModeIsActive()){
            telemetry.update();
        }
        motor1.setPower(0);
        motor2.setPower(0);
        motor3.setPower(0);
        motor4.setPower(0);
    }
}